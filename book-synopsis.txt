Грокаем алгоритмы (конспект)

1 ЗНАКОМСТВО С АЛГОРИТМАМИ

Алгоритм - набор инструкций для выполнения задачи.

Бинарный поиск - алгоритм, который получает на вход отсортированный список элементов, если элемент, который вы ищите, есть в списке, то бинарный поиск возвращает ту позицию, в которой он был найден. В противном случае возвращает null.

В общем случае для списка из n элементов бинарный поиск выполняется за log2n шагов.

Линейное время - время, когда максимальное кол-во попыток совпадает с размером списка.

Простой поиск: O(n)
Бинарный поиск: O(Log n)

«О-большое» описывает скорость работы алгоритма (кол-во операций).

«О-большое» определяет худшее время выполнения алгоритма.

2 СОРТИРОВКА ВЫБОРОМ

Память компьютера - огромный шкаф с ящиками.

В массиве все элементы хранятся в памяти рядом друг с другом.

В списке все элементы распределяются в произвольных местах памяти, при этом в одном элементе хранится адрес следующего.

Все элементы массива должны быть однотипными.

Чтение: массивы - O(1) списки - O(n)
Вставка: массивы - O(n) списки - O(1)
Удаление: массивы - O(n) списки - O(1)

Всего существует 2 вида доступа: произвольный и последовательный.

3 РЕКУРСИЯ

Рекурсия - вызов функцией самой себя.

"Циклы могут ускорить работу программы. Рекурсия может ускорить работу программиста. Выбирайте, что важнее в вашей ситуации!" - Ли Колдуэлл

Каждая рекурсивная функция состоит из двух частей: базовый случай и рекурсивный случай.

Стек - простая структура данных, в которой новый элемент добавляется в начало, последний элемент извлекается из начала.

Когда вы вызываете функцию из другой функции, вызывающая функция приостанавливается в частично завершенном состоянии.

Стек вызовов - стек, в котором сохранялись переменные разных функций.

Все вызовы функций сохраняются в стеке вызовов.

Если стек вызовов станет очень большим, он займёт слишком много памяти.

4 БЫСТРАЯ СОРИТОРОВКА

Столкнувшись с новой задачей, не впадайте в ступор. Вместо этого спросите себя: "А нельзя ли решить эту задачу, применив стратегию 'разделяй и властвуй'?"

Как работает стратегия "разделяй и властвуй":
1. Определите простейший случай как базовый.
2. Придумайте, как свести задачу к базовому случаю.

"Разделяй и влавствуй" - это не простой алгоритм для решения задачи, это подход к решению задачи.

Совет: когда вы пишите рекурсивную функцию, в которой задействован массив, базовым случаем часто оказывается пустой массив или массив из одного элемента.

Когда вы используете "О-большое" (например, O(n)), в действительности это означает: c * n (фиксированный промежуток времени). Здесь c  - некоторый промежуток времени. Он называется константой.

Обычно константа игнорируется, потому что если два алгоритма имеют разное время "O-большое", она роли не играет.

Быстрая сортировка быстрее сортировки слиянием.

Если вы реализуете алгоритм быстрой сортировки, выберите в качестве опорного случайный элемент. Среднее время выполнения быстрой сортировки составляет O(n log n).

5 ХЭШ-ТАБЛИЦЫ

Хэш-функция представляет собой функцию, которая получает строку и возвращает число.

Хэш-функция должна соответствовать требованиям:
- Должна быть последовательной
- Разным словам должны соответствовать разные числа

Хэш-функция неизменно связывает название с одним индексом.
Хэш-функция связывает разные строки с разными индексами.
Хэш-функция знает размер массива и возвращает только действительные индексы.

Хэш-таблица = хэш-функция + массив

Хэш-таблица состоит из ключей и значений.

Примеры использования хэш-таблиц:
- Поиск
- Исключение дубликатов
- Кэш

Кэширование - запомнить данные, вместо того, чтобы пересчитать их заново.

Преимущество кэширования:
- Скорость
- Меньшая затрата ресурсов сервера

Кешируемые данные хранятся в хэше.

Коллизия - двум ключам назначается один элемент массива.

Если несколько ключей отображаются на один элемент, создаётся связанный список.

В идеале, хэш-функция должна распределять ключи равномерно по всему массиву.

Если связанные списки становятся слишком длинными, работа хэш-функции замедляется.

Хорошая хэш-функция создаёт минимальное число коллизий.

В среднем хэш-таблицы выполняют любые операции за время O(1) (постоянное время). То есть при любом размере хэш-таблицы выборка данных займёт одинаковое время.

Для предотвращения коллизий необходимы:
- низкий коэффициент заполнения
- хорошая хэш-функция

6 ПОИСК В ШИРИНУ

Поиск в ширину позволяет найти кратчайшее расстояние между двумя объектами.

С помощью поиска в ширину можно:
- написать программу для игры в шашки
- реализовать проверку правописания
- найти ближайшего к вам врача

Поиск в ширину - это алгоритм для решения задачи поиска кратчайшего пути.

Граф моделирует набор связей.

Граф состоит из узлов и рёбер.

Узел может быть напрямую соединён с с несколькими другими узлами. Такие узлы называются соседями.

Поиск в ширину также относится к категории алгоритмов поиска, но этот алгоритм работает с графами. Он помогает ответить на вопросы:
- существует ли путь от узла A к узлу B?
- как выглядит кратчайший путь от узла A к узлу B?

Очереди чем-то похожи на стеки: вы не можете обращаться к произвольным элементам очереди. Вместо этого поддерживаются всего две операции: постановка в очередь и извлечение из очереди.

Если вы поставите в очередь два элемента, то элемент, добавленный первым, будет извлечён из очереди раньше второго.

Очередь: FIFO: First In, First Out.
Стек: LIFO: Last In, First Out.

Направленный граф - граф в котором отношения между узлами, действуют только в одну сторону.

Поиск в ширину выполняется за время O(кол-во вершин + кол-во рёбер).

Разновидность графа, в которой нет рёбер, указывающих в обратном направлении, называется деревом.

7 АЛГОРИТМ ДЕЙКСТРЫ

С каждым ребром графа связывается число - вес.

Взвешенный граф - граф с весами.
Невзвешенный граф - граф без весов.

Поиск в ширину вычисляет кратчайший путь в невзвешенном графе.
Алгоритм Дейкстры вычисляет кратчайший путь во взвешенном графе.

Алгоритм Дейкстры состоит из четырёх шагов:
1. Найти узел с наименьшей стоимостью
2. Обновить стоимости соседей
3. Повторять, пока это не будет сделано для всех узлов графа
4. Вычислить итоговый путь

Алгоритм Дейкстры работает только с направленными ациклическими графами.

Ключевая идея Алгоритма Дейкстры: в графе ищется путь с наименьшей стоимостью. Пути к этому узлу с меньшими затратами не существует.

Проходя по родительским узлом в обратном направлении, мы получаем полный путь.

Кратчайший путь далеко не всегда связывается с физическим расстоянием: он может быть направлен на минимизацию какой-либо характеристики.

Алгоритм Дейкстры не может использоваться при наличии рёбер с отрицательным весом. Для этого используется алгоритм Беллмана-Форда.

8 ЖАДНЫЕ АЛГОРИТМЫ

Жадные алгоритмы очень просты.

В технической треминологии: на каждом шаге выбирается локально-оптимальное решение, а в итоге вы получаете глобально-оптимальное решение.

В некоторых случаях достаточно алгоритма, способного решить задачу достаточно хорошо. Жадные алгоритмы реализуются просто, а полученное решение обычно близко к оптимуму.

Когда вычисление точного решения занимает слишком много времени, применяется приближенный алгоритм. Эффективность приближенного алгоритма оценивается по:
- быстроте
- близости полученного решения к оптимальному

- Объединение множеств это элементы обоих множеств.
- Пересечение множеств это элементы входящие в оба множества.
- Разность множеств это исключение из одного множества элементов, присутствующих в другом множестве.

- Множества похожи на списки, но не содержат дубликатов.
- С множествами можно выполнять различные операции - вычислять объединение, пересечение и разность.

Признаки, что задача является NP-полной:
- Алгоритм быстро работает при малом количестве элементов, но сильно замедляется при увеличении их числа.
- Формулировка "все комбинации X" часто указывают на NP-полному задачи.
- Вам приходится вычислять все возможные варианты X, потому что задачу невозможно разбить не меньшие подзадачи.
- Если в задаче встречается последовательность, и задача не имеет простого решения.
- Если в задаче встречается некоторое множество, и задача не имеет простого решения.
- Можно ли переформулировать задачу в условиях задачи покрытия множества или задачи о  коммивояжере.

9 ДИНАМИЧЕСКОЕ ПРОГРАММИРОВАНИЕ

Динамическое программирование - мощный метод, способный решать подзадачи и использовать полученные ответы для решения большой задачи. Динамическое программирование работает только в том случае, если каждая подзадача автономна, то есть не зависит от других подзадач.

- Динамическое программирование применяется для оптимизации какой-либо характеристики при заданных ограничениях.

- В каждом решении из области динамического программирования строится таблица.
- Значения ячеек таблицы обычно соответствуют оптимизируемой характеристике.
- Каждая ячейка представляет подзадачу, поэтому нужно подумать, как разбить задачу на подзадачи.

- Не существует единой формулы для вычисления решений методом динамического программирования.

10 АЛГОРИТМ K БЛИЖАЙШИХ СОСЕДЕЙ

Алгоритм k ближайших соседей прост, но полезен! Если вы пытаетесь выполнить классификацию чего-либо, сначала попробуйте применить алгоритм k ближайших соседей.

Для вычисления расстояния между двумя точками применяется формула Пифагора:
Math.sqrt(Math.sqr(x1 - x2) + Math.sqr(y1 - y2))

Формула расстояния универсальна: даже если вы используете набор из миллиона чисел, расстояние вычисляется по той же формуле.

У алгоритма k ближайших соседей есть два основных применения: классификация и регрессия:
- классификация = распределение по категориям;
- регрессия = прогнозирование ответа (в числовом выражении);

- "Извлечением признаков" называется преобразование элемента в список чисел, которые могут использоваться для сравнения.
- Качественный выбор признаков - важная часть успешного алгоритма k ближайших соседей.
